#version 400
#pragma vp_name "Flora tessellation control shader"

/**
 * TCS that distributes data based on a Land Use code sampler.
 */
 
#pragma vp_entryPoint "oe_landcover_configureTess"
#pragma vp_location   "tess_control"

layout(vertices = 3) out;

uniform float oe_landcover_density;

vec2 oe_terrain_scaleCoordsToRefLOD(in vec2, in float);


// Land Use sampler+matrix (set these in your earth file)
uniform sampler2D landUseTex;
uniform mat4      landUseTexMatrix;

uniform sampler2D oe_noise_tex;
uniform float     shmoo;

// stage global: tile coordinates
vec4 oe_layer_tilec;

// declare the coverage acceptance function, generated by LandCoverBiome
bool oe_landcover_passesCoverage(in vec4 coords);


// MAIN ENTRY POINT                
void oe_landcover_configureTess()
{
	if (gl_InvocationID == 0)
	{
        //TODO: sample at each corner and adjust tess levels individually
        //float r0 = texture(oe_noise_tex, oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, 6.0)).r;
        float r0 = 1.0;

        //if ( r0 > shmoo )
        
        //float code = textureLod(landUseTex, (landUseTexMatrix * oe_layer_tilec).st, 0).r;
        //float rrr = texture(oe_noise_tex, oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, 12.0)).g;
        
        if ( oe_landcover_passesCoverage(oe_layer_tilec) )
        {
            float d = oe_landcover_density * r0;

            gl_TessLevelOuter[0] = d;
            gl_TessLevelOuter[1] = d;
            gl_TessLevelOuter[2] = d;
            gl_TessLevelInner[0] = d;
        }
        else
        {
            gl_TessLevelOuter[0] = 0;
            gl_TessLevelOuter[1] = 0;
            gl_TessLevelOuter[2] = 0;
            gl_TessLevelInner[0] = 0;
        }
	}
}
