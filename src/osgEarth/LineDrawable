/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2016 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_LINEDRAWABLE_H
#define OSGEARTH_LINEDRAWABLE_H 1

#include <osgEarth/Common>
#include <osg/Array>
#include <osg/Geometry>
#include <osg/Group>

namespace osgEarth
{
    /**
     * Drawable that renders lines using the GPU. It will fall back on rendering
     * OpenGL lines when shader-based rendering is unavailable.
     *
     * Note: Put LineDrawables under a LineGroup to share the shader program.
     * If you don't use a LineGroup, you must call installShader() on your
     * LineDrawable.
     *
     * Note: If you use this class you must have the oe_ViewportSize
     * uniform set. MapNode sets it automatically so any LineDrawable under
     * a MapNode is fine. Otherwise, use the osgEarth::InstallViewportSizeUniform
     * callback on your scene graph.
     */
    class OSGEARTH_EXPORT LineDrawable : public osg::Drawable
    {
    public:
        //! Create a new LineDrawable.
        //! @param[in ] mode GL line mode: GL_LINE_STRIP or GL_LINE_LOOP
        LineDrawable(GLenum mode);

        //! Copy constructor
        LineDrawable(const LineDrawable& rhs, const osg::CopyOp& copy);
        
        //! Append a vertex to the line
        void pushVertex(const osg::Vec3& vert);

        //! Set the value of a vertex at index i
        void setVertex(unsigned i, const osg::Vec3& vert);

        //! Copy a vertex array into the drawable
        void setVerts(const osg::Vec3Array* verts);

        //! Width in pixels of the line
        void setLineWidth(float width_pixels);

        //! Stippling parameters for the line
        void setStippling(short factor, short pattern);

        //! Creates a new vertex attribute array on this drawable
        template<typename T>
        T* addVertexAttribArray(int location);

        //! Appends a vertex to an attribute array created by calling 
        //! addVertexAttributeArray
        template<typename T>
        void pushVertexAttrib(T* vaa, const typename T::ElementDataType& value);

        //! Pre-allocate space for vertices
        void reserve(unsigned size);

        //! Rebuild the primitive sets for this drawable. You MUST call this
        //! after adding new data to the drawable!
        void dirty();

        //! Install shaders to render the line drawable when GPU rendering is
        //! available. You only need to call this if you are not using a LineGroup.
        void installShader();

    public:

        //! Binding location for "previous" vertex attribute (default = 9)
        static int PreviousVertexAttrLocation;

        //! Binding location for "next" vertex attribute (default = 10)
        static int NextVertexAttrLocation;

    public: // osg::Drawable pass-throughs

        void drawImplementation(osg::RenderInfo& ri) const;

        void compileGLObjects(osg::RenderInfo& ri) const { _geom->compileGLObjects(ri); }

        void resizeGLObjectBuffers(unsigned maxSize) { _geom->resizeGLObjectBuffers(maxSize); }

        void releaseGLObjects(osg::State* state) const { _geom->releaseGLObjects(state); }

        osg::BoundingSphere computeBound() const { return _geom->computeBound(); }

        osg::BoundingBox computeBoundingBox() const { return _geom->computeBoundingBox(); }

        virtual bool supports(const osg::Drawable::AttributeFunctor& af) const { return _geom->supports(af); }

        virtual void accept(Drawable::AttributeFunctor& af) { _geom->accept(af); }

        virtual bool supports(const osg::Drawable::ConstAttributeFunctor& af) const { return _geom->supports(af); }

        virtual void accept(osg::Drawable::ConstAttributeFunctor& af) const { _geom->accept(af); }

        virtual bool supports(const osg::PrimitiveFunctor& pf) const { return _geom->supports(pf); }

        virtual void accept(osg::PrimitiveFunctor& pf) const { _geom->accept(pf); }

        virtual bool supports(const osg::PrimitiveIndexFunctor& pf) const { return _geom->supports(pf); }

        virtual void accept(osg::PrimitiveIndexFunctor& pf) const { _geom->accept(pf); }

        //TODO replace?
        osg::Geometry* asGeometry() { return _geom.get(); }
        const osg::Geometry* asGeometry() const { return _geom.get(); }

    private:
        GLenum _mode;
        bool _gpu;
        osg::ref_ptr<osg::Geometry>   _geom;
        osg::ref_ptr<osg::Vec3Array>  _current;
        osg::ref_ptr<osg::Vec3Array>  _previous;
        osg::ref_ptr<osg::Vec3Array>  _next;
    };
    
    // Template implementations ..........................................

    template<typename T>
    T* LineDrawable::addVertexAttribArray(int location)
    {
        T* a = new T();
        a->reserve(_current->size());
        _geom->setVertexAttribArray(location, a);
        return a;
    }

    template<typename T>
    void LineDrawable::pushVertexAttrib(T* vaa, const typename T::ElementDataType& value)
    {
        vaa->push_back(value);
        if (_gpu)
            vaa->push_back(value);
    }

    //....................................................................

    /**
     * Group for collecting multiple LineDrawables. If you put one or more
     * LineDrawables under a LineGroup, you do not need to call installShader()
     * on each LineDrawable because the LineGroup installs the shader for the
     * entire set.
     */
    class OSGEARTH_EXPORT LineGroup : public osg::Group
    {
    public:
        //! Construct a new line group
        LineGroup();

    protected:
        //! destructor
        virtual ~LineGroup() { }

        bool _gpu;
    };


} // namespace osgEarth

#endif // OSGEARTH_LINEDRAWABLE_H
