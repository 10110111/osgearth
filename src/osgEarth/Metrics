/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2012 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_METRICS_H
#define OSGEARTH_METRICS_H 1

#include <osgEarth/Common>
#include <osgEarth/Config>
#include <iostream>
#include <osgDB/fstream>

namespace osgEarth
{
    /**
     * Interface for a class that handles collecting metrics.
     */
    class OSGEARTH_EXPORT MetricsBackend : public osg::Referenced
    {
    public:
        /**
         * Begins an event.
         * @param name
         *        The name of the event
         * @param args
         *        The arguments to the event.
         */
        virtual void begin(const std::string& name, const Config& args =Config()) = 0;

        /**
         * Ends an event
         * @param name
         *        The name of the event.
         */
        virtual void end(const std::string& name) = 0;

        /**
         * A counter event
         * @param name
         *        The name of the counter
         * @param value
         *        The value of the counter.
         */
        virtual void counter(const std::string& name, double value) = 0;
    };

    /**
     * A MetricsProvider that uses the chrome://tracing format as described here: http://www.gamasutra.com/view/news/176420/Indepth_Using_Chrometracing_to_view_your_inline_profiling_data.php
     * https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit?pli=1#
     */
    class OSGEARTH_EXPORT ChromeMetricsBackend : public MetricsBackend
    {
    public:
        ChromeMetricsBackend(const std::string& filename);
        ~ChromeMetricsBackend();

        virtual void begin(const std::string& name, const Config& args =Config());
        virtual void end(const std::string& name);
        virtual void counter(const std::string& name, double value);


    protected:
        std::ofstream _metricsFile;
        OpenThreads::Mutex _mutex;    
        bool _firstEvent;
    };

    class OSGEARTH_EXPORT Metrics
    {
    public:
        /**
         * Begins an event.
         * @param name
         *        The name of the event
         * @param args
         *        The arguments to the event.
         */
        static void begin(const std::string& name, const Config& args =Config());

        /**
         * Ends an event
         * @param name
         *        The name of the event.
         */
        static void end(const std::string& name);

        /**
         * A counter event
         * @param name
         *        The name of the counter
         * @param value
         *        The value of the counter.
         */
        static void counter(const std::string& name, double value);

        /**
         * Sets the MetricsBackend
         */
        static void setMetricsBackend( MetricsBackend* backend );
    };

    /**
     * Utility that lets you start and stop metrics with a single line of code
     * @example
     * void myFunction() {
     *     ScopedMetric("myFunction");
     *     ...do some work
     * }
     */
    class OSGEARTH_EXPORT ScopedMetric
    {
    public:
        ScopedMetric(const std::string& name, const Config& args =Config());
        ~ScopedMetric();
        std::string _name;
        Config _args;
    };

};

#endif
