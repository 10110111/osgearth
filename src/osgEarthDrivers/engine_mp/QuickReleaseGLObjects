/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2015 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_QUICK_RELEASE_GL_OBJECTS
#define OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_QUICK_RELEASE_GL_OBJECTS 1

#include "Common"
#include "TileNodeRegistry"
#include <osgEarth/ResourceReleaser>
#include <osg/Camera>

namespace osgEarth { namespace Drivers { namespace MPTerrainEngine
{
#if 0
    /**
     * This is an adapter for MP to use the ResourceReleaser. 
     * Each frame it will copy tiles from the "dead pool" over to
     * the releaser, which will release them during the next DRAW.
     */
    class MPResourceReleaser : public ResourceReleaser
    {
    public:
        MPResourceReleaser(TileNodeRegistry* deadTiles) :
            ResourceReleaser(),
            _deadTiles(deadTiles)
        {
            //nop
        }

        virtual ~MPResourceReleaser()
        {
            //nop
        }

    public: // ResourceReleaser

        // thread-safe operation that transfers dead tiles from the registry
        // to the resource releaser for processing.
        struct TransferOp : public TileNodeRegistry::Operation
        {
            TransferOp(ResourceReleaser* releaser) : _releaser(releaser) { }

            void operator()(TileNodeRegistry::TileNodeMap& tiles)
            {
                ResourceReleaser::ObjectList objects;

                for( TileNodeRegistry::TileNodeMap::iterator i = tiles.begin(); i != tiles.end(); ++i )
                {
                    objects.push_back(i->second.get());
                }
                tiles.clear();

                _releaser->push(objects);
            }

            ResourceReleaser* _releaser;
        };

        void accept(osg::NodeVisitor& nv) // traverse doesn't work here
        {
            if (nv.getVisitorType() == nv.CULL_VISITOR)
            {
                TransferOp transfer(this);
                _deadTiles->run(transfer);
            }
            ResourceReleaser::accept(nv);
        }

    private:
        osg::ref_ptr<TileNodeRegistry> _deadTiles;
    };    
#endif

} } } // namespace

#endif // OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_QUICK_RELEASE_GL_OBJECTS
