/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2014 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_REX_TERRAIN_DRAWABLE_H
#define OSGEARTH_REX_TERRAIN_DRAWABLE_H 1

#include <osgEarth/MapFrame>
#include <osgEarth/ImageLayer>

#include "EngineContext"

#include <osg/NodeVisitor>
#include <osg/GLExtensions>
#include <osg/StateSet>

#include <list>
#include <map>
#include <vector>

using namespace osgEarth;

namespace osgEarth { namespace Drivers { namespace RexTerrainEngine
{
    /**
     * Tracks the state of a single sampler through the draw process,
     * to prevent redundant OpenGL texture binding and matrix uniform sets.
     */
    struct SamplerState
    {
        SamplerState() : _matrixUL(-1) { }
        optional<osg::Texture*> _texture;    // Texture currently bound
        optional<osg::Matrixf> _matrix;      // Matrix that is currently set
        GLint _matrixUL;                     // Matrix uniform location

        void clear() {
            _texture.clear();
            _matrix.clear();
        }

        void clearUniformData() {
            _matrix.clear();
            _matrixUL = -1;
        }
    };

    /**
     * Tracks the state of all samplers used in render a tile,
     * to prevent redundant OpenGL binds.
     */
    struct TileSamplerState
    {
        std::vector<SamplerState> _samplers;

        void clear() {
            for (unsigned i = 0; i<_samplers.size(); ++i)
                _samplers[i].clear();
        }

        void clearUniformData() {
            for (unsigned i = 0; i<_samplers.size(); ++i)
                _samplers[i].clearUniformData();
        }
    };

    /**
     * Tracks the state of terrain drawing settings in a single frame,
     * to prevent redundant OpenGL calls.
     */
    struct DrawState : public osg::Referenced
    {
        bool _stateInitialized;

        // uniform locations
        GLint _tileKeyUL;
        GLint _parentTextureExistsUL;
        GLint _layerUidUL;
        GLint _layerOpacityUL;
        GLint _layerOrderUL;
        GLint _layerMinRangeUL;
        GLint _layerMaxRangeUL;
        GLint _elevTexelCoeffUL;
        GLint _morphConstantsUL;

        osg::ref_ptr<osg::GLExtensions> _ext;

        optional<int>        _layerOrder;
        optional<osg::Vec2f> _elevTexelCoeff;
        optional<osg::Vec2f> _morphConstants;
        optional<bool>       _parentTextureExists;

        TileSamplerState _samplerState;

        const RenderBindings* _bindings;

        const osg::Program::PerContextProgram* _pcp;

        osg::BoundingSphere _bs;
        osg::BoundingBox    _box;

        DrawState() :
            _stateInitialized(false),
            _tileKeyUL(-1),
            _parentTextureExistsUL(-1),
            _layerUidUL(-1),
            _layerOpacityUL(-1),
            _layerOrderUL(-1),
            _layerMinRangeUL(-1),
            _layerMaxRangeUL(-1),
            _elevTexelCoeffUL(-1),
            _morphConstantsUL(-1),
            _ext(0L),
            _bindings(0L),
            _pcp(0L)
        {
            //nop
        }

        // Ensures that the Uniform Locations in the DrawState correspond to
        // the currently applied program object.
        void refresh(osg::RenderInfo& ri)
        {
            // Establish a GL Extensions handle:
            if (!_ext.valid())
            {
                _ext = osg::GLExtensions::Get(ri.getContextID(), true);
            }
                
            // Size the sampler states property:
            if (_samplerState._samplers.size() < _bindings->size())
            {
                _samplerState._samplers.resize(_bindings->size());
            }

            const osg::Program::PerContextProgram* pcp = ri.getState()->getLastAppliedProgramObject();
            if (pcp && (pcp != _pcp))
            {
                // Reset all sampler matrix states since their uniform locations are going to change.
                _layerOrder.clear();
                _elevTexelCoeff.clear();
                _morphConstants.clear();
                _parentTextureExists.clear();
                _samplerState.clear();

                // for each sampler binding, initialize its state tracking structure 
                // and resolve its matrix uniform location:
                for (unsigned i = 0; i < _bindings->size(); ++i)
                {
                    const SamplerBinding& binding = (*_bindings)[i];
                    _samplerState._samplers[i]._matrixUL = pcp->getUniformLocation(osg::Uniform::getNameID(binding.matrixName()));
                }

                // resolve all the other uniform locations:
                _tileKeyUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_key"));
                _elevTexelCoeffUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_elevTexelCoeff"));
                _parentTextureExistsUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_texParentExists"));
                _layerUidUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_uid"));
                _layerOpacityUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_opacity"));
                _layerOrderUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_order"));
                _layerMinRangeUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_minRange"));
                _layerMaxRangeUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_maxRange"));
                _morphConstantsUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_morph"));
            }

            _pcp = pcp;
        }
    };

    /**
     * All data necessary to draw a single terrain tile.
     */
    struct DrawTileCommand
    {
        // Model matrix assocaited with this tile.
        osg::Matrixd _matrix;

        // ModelView matrix to apply before rendering this tile
        osg::Matrixf _modelViewMatrix;

        // Rendering pass that contains this tile. The pass contains
        // the set of samplers we need to bind.
        const RenderingPass* _pass;

        // Tile geometry, if present
        osg::Geometry* _geom;

        // Tile key - just for debugging
        TileKey _key;

        // Tile key value to push to uniform just before drawing
        osg::Vec4f _keyValue;

        // Elevation texel sampling coefficients (so we sample elevation
        // data on center rather than on edge) - We might be able to move
        // this to the Layer level as long as the elevation texture size
        // doesn't change
        osg::Vec2f _elevTexelCoeff;

        // Coefficient used for tile vertex morphing
        osg::Vec2f _morphConstants;

        // Custom draw callback to call instead of rendering _geom
        Layer::DrawCallback* _drawCallback;

        // When drawing _geom, whether to render as GL_PATCHES 
        // instead of GL_TRIANGLES (for patch layers)
        bool _drawPatch;

        // Distance from camera to center of tile
        float _range;


        void draw(osg::RenderInfo& ri, DrawState& env) const;

        // Less than operator will ensure that tiles are sorted high-to-low LOD
        // (to minimize Z overdraw) and then grouped by shared geometry
        // (to minimize buffer binds). Both of these make a significant performance
        // difference based on benchmarking.
        bool operator < (const DrawTileCommand& rhs) const
        {
            if (_key.getLOD() > rhs._key.getLOD()) return true;
            if (_key.getLOD() < rhs._key.getLOD()) return false;
            return _geom < rhs._geom;
        }

        DrawTileCommand() :
            _pass(0L), _geom(0L),
            _elevTexelCoeff(1.0f, 0.0f),
            _drawCallback(0L),
            _drawPatch(false),
            _range(0.0f) { }
    };

    /**
     * Ordered list of tile drawing commands.
     * List is faster than vector here (benchmarked)
     */
    typedef std::list<DrawTileCommand> DrawTileCommands;


    /**
     * Drawable for single "Layer" i.e. rendering pass. 
     * It is important that LayerDrawables be rendered in the order in which
     * they appear. Since all LayerDrawables share a common bounds, this 
     * should happen automatically, but let's keep an eye out for trouble.
     */
    class LayerDrawable : public osg::Drawable
    {
    public:
        LayerDrawable();

        // The (sorted) list of tiles to render for this layer
        DrawTileCommands  _tiles;

        // Pointer back to the actual Map layer, if there is one
        const Layer* _layer;

        // If _layer is an ImageLayer, this will be set as well, otherwise NULL
        const ImageLayer* _imageLayer;

        // Layer render order, which is pushed into a Uniform at render time.
        // This value is assigned at cull time by RexTerrainEngineNode.
        int _order;

        // The last layer to render will have this flag set, which will
        // prompt the render to dirty the osg::State to prevent corruption.
        // This flag is set at cull time by RexTerrainEngineNode.
        bool _clearOsgState;

        // Reference the terrain-wide state
        osg::ref_ptr<DrawState> _drawState;
        

    public: // osg::Drawable
        
        void drawImplementation(osg::RenderInfo& ri) const;

        // All LayerDrawables share the common terrain bounds.
        osg::BoundingSphere computeBound() const { return _drawState->_bs; }
        osg::BoundingBox computeBoundingBox() const { return _drawState->_box; }
    };


    // Straight list of LayerDrawables.
    typedef std::vector< osg::ref_ptr<LayerDrawable> > LayerDrawableList;

    // LayerDrawables indexed by a UID.
    typedef std::map<UID, osg::ref_ptr<LayerDrawable> > LayerDrawableMap;


    /**
     * Main data structure assembled by the TerrainCuller that contains
     * everything necessary to render one frame of the terrain.
     */
    class TerrainRenderData
    {
    public:
        TerrainRenderData() :
            _bindings(0L) { }

        /** Set up the map layers before culling the terrain */
        void setup(const MapFrame& frame, const RenderBindings& bindings, osg::StateSet* defaultSS);

        /** Optimize for best state sharing (when using geometry pooling) */
        void sortDrawCommands();

        /** Add a layer (in order) */
        LayerDrawable* addLayer(const Layer*);

        /** Layers to draw */
        LayerDrawableList& layers() { return _layerList; }
        const LayerDrawableList& layers() const { return _layerList; }

        /** Look up a LayerDrawable by its source layer UID. */
        osg::ref_ptr<LayerDrawable>& layer(UID uid) { return _layerMap[uid]; }

        // Draw state shared by all layers during one frame.
        osg::ref_ptr<DrawState> _drawState;
        
    private:

        LayerDrawableList     _layerList;
        LayerDrawableMap      _layerMap;
        const RenderBindings* _bindings;
    };

} } } // namespace 

#endif // OSGEARTH_REX_TERRAIN_DRAWABLE_H
