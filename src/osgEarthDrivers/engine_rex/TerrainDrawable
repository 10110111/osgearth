/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2014 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_REX_TERRAIN_DRAWABLE_H
#define OSGEARTH_REX_TERRAIN_DRAWABLE_H 1

#include <osgEarth/MapFrame>
#include <osgEarth/ImageLayer>

#include "EngineContext"

#include <osg/NodeVisitor>
#include <osg/GLExtensions>
#include <osg/StateSet>

#include <list>
#include <map>
#include <vector>

using namespace osgEarth;

namespace osgEarth { namespace Drivers { namespace RexTerrainEngine
{
    /**
     * Tracks the state of a single sampler through the draw process,
     * to prevent redundant OpenGL texture binding and matrix uniform sets.
     */
    struct SamplerState
    {
        SamplerState() : _matrixUL(-1) { }
        optional<osg::Texture*> _texture;    // Texture currently bound
        optional<osg::Matrixf> _matrix;      // Matrix that is currently set
        GLint _matrixUL;                     // Matrix uniform location
    };

    /**
     * Tracks the state of all samplers used in render a tile,
     * to prevent redundant OpenGL binds.
     */
    struct TileSamplerState
    {
        std::map<UID, SamplerState> _colorPasses;
        std::vector<SamplerState> _samplers;
    };

    /**
     * Tracks the state of terrain drawing settings in a single frame,
     * to prevent redundant OpenGL calls.
     */
    struct DrawState : public osg::Referenced
    {
        bool _stateInitialized;

        // uniform locations
        GLint _tileKeyUL;
        GLint _parentTextureExistsUL;
        GLint _layerUidUL;
        GLint _layerOpacityUL;
        GLint _layerOrderUL;
        GLint _layerMinRangeUL;
        GLint _layerMaxRangeUL;
        GLint _elevTexelCoeffUL;
        GLint _morphConstantsUL;

        osg::GLExtensions* _ext;

        optional<int>        _layerOrder;
        optional<osg::Vec2f> _elevTexelCoeff;
        optional<osg::Vec2f> _morphConstants;
        optional<bool>       _parentTextureExists;

        TileSamplerState _samplerState;

        const RenderBindings* _bindings;

        osg::BoundingSphere _bs;
        osg::BoundingBox    _box;

        DrawState() : _stateInitialized(false) { }
        
        void initialize(osg::RenderInfo& ri)
        {
            _ext = osg::GLExtensions::Get(ri.getContextID(), true);

            // Size the sampler states property:
            _samplerState._samplers.resize(_bindings->size());

            const osg::Program::PerContextProgram* pcp = ri.getState()->getLastAppliedProgramObject();
            if (pcp)
            {
                // for each sampler binding, initialize its state tracking structure 
                // and resolve its matrix uniform location:
                for (unsigned i = 0; i < _bindings->size(); ++i)
                {
                    const SamplerBinding& binding = (*_bindings)[i];
                    _samplerState._samplers[i]._matrixUL = pcp->getUniformLocation(osg::Uniform::getNameID(binding.matrixName()));
                }

                // resolve all the other uniform locations:
                _tileKeyUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_key"));
                _elevTexelCoeffUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_elevTexelCoeff"));
                _parentTextureExistsUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_texParentExists"));
                _layerUidUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_uid"));
                _layerOpacityUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_opacity"));
                _layerOrderUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_order"));
                _layerMinRangeUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_minRange"));
                _layerMaxRangeUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_layer_maxRange"));
                _morphConstantsUL = pcp->getUniformLocation(osg::Uniform::getNameID("oe_tile_morph"));
            }

            _stateInitialized = true;
        }
    };

    /**
     * All data necessary to draw a single terrain tile.
     */
    struct DrawTileCommand
    {
        osg::Matrixd _matrix;
        osg::Matrixf _modelViewMatrix;
        osg::Geometry* _geom;
        double _depth;
        TileKey _key;
        osg::Vec4f _keyValue;
        osg::Vec2f _elevTexelCoeff;
        osg::Vec2f _morphConstants;
        const RenderingPass* _pass;

        void draw(osg::RenderInfo& ri, DrawState& env) const;

        bool operator < (const DrawTileCommand& rhs) const {
            //return _geom.get() < rhs._geom.get();
            return _geom < rhs._geom;
        }

        DrawTileCommand() :
            _elevTexelCoeff(1.0f, 0.0f) { }
    };

    /**
     * Ordered list of tile drawing commands.
     */
    typedef std::list<DrawTileCommand> DrawTileCommands;


    class LayerDrawable : public osg::Drawable
    {
    public:
        LayerDrawable();

        //void setDrawState(DrawState* env) { _env = env; }

        int _order;
        DrawTileCommands  _tiles;
        const ImageLayer* _layer;
        class TerrainDrawable* _terrain;

        osg::ref_ptr<DrawState> _env;

        

    public: // osg::Drawable
        
        void drawImplementation(osg::RenderInfo& ri) const;

        osg::BoundingSphere computeBound() const { return _env->_bs; }

        osg::BoundingBox computeBoundingBox() const { return _env->_box; }

    private:
        //DrawState* _env;
    };

    typedef std::vector< osg::ref_ptr<LayerDrawable> > LayerDrawableList;

    typedef std::map<UID, osg::ref_ptr<LayerDrawable> > LayerDrawableMap;
    
#if 0
    /**
     * All data necessary to draw a single map layer.
     */
    struct DrawLayerCommand
    {
        const ImageLayer* _layer;
        DrawTileCommands _tiles;
        osg::ref_ptr<osg::StateSet> _stateSet;

        void draw(osg::RenderInfo& ri, DrawState& env) const;

        DrawLayerCommand() : _layer(0L) { }
    };

    /**
     * Ordered list of map layers to draw.
     */
    typedef std::list<DrawLayerCommand> DrawLayerCommandList;

    /**
     * Map layers indexed by layer UID (for fast lookups)
     */
    typedef std::map<UID, DrawLayerCommand*> DrawLayerCommandMap;
#endif

    /**
     * Drawable submitted to the OSG cull visitor that is responsible
     * for rendering the entire terrain. The TerrainCuller assembles
     * this object during the CULL traversal.
     */
    class TerrainDrawable : public osg::Drawable
    {
    public: // osg::Drawable
        void drawImplementation(osg::RenderInfo& ri) const;

        //osg::BoundingSphere computeBound() const { return _bs; }

        //osg::BoundingBox computeBoundingBox() const { return _box; }

        void compileGLObjects(osg::RenderInfo& renderInfo) const;

    public:
        TerrainDrawable();

        /** Draw the terrain. */
        void draw(osg::RenderInfo& ri, DrawState& env) const;

        /** Set up the map layers before culling the terrain */
        void setup(const MapFrame& frame, const RenderBindings& bindings);

        /** Optimize for best state sharing (when using geometry pooling) */
        void sortDrawCommands();

        /** Add a layer (in order) */
        LayerDrawable* addLayer(const ImageLayer*);

        /** Layers to draw */
        LayerDrawableList& layers() { return _layerList; }
        const LayerDrawableList& layers() const { return _layerList; }
        osg::ref_ptr<LayerDrawable>& layer(UID uid) { return _layerMap[uid]; }

        //osg::BoundingSphere   _bs;
        //osg::BoundingBox      _box;
        
        osg::ref_ptr<DrawState> _drawState;
        
    private:

        LayerDrawableList     _layerList;
        LayerDrawableMap      _layerMap;
        const RenderBindings* _bindings;
    };

} } } // namespace 

#endif // OSGEARTH_REX_TERRAIN_DRAWABLE_H
